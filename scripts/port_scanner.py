import socket
import argparse
from concurrent.futures import ThreadPoolExecutor

def scan_port(host, port, verbose, timeout):
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.settimeout(timeout)
            result = sock.connect_ex((host, port))
            if result == 0:
                if verbose:
                    print(f"[+] Port {port} is open on {host}")
                return port
            else:
                if verbose:
                    print(f"[-] Port {port} is closed on {host}")
                return None
    except (socket.error, socket.timeout) as e:
        if verbose:
            print(f"[!] Could not connect to {host}:{port} - {e}")
        return None

def scan_ports(host, start_port, end_port, verbose, timeout=1):
    open_ports = []
    with ThreadPoolExecutor(max_workers=100) as executor:
        futures = {executor.submit(scan_port, host, port, verbose, timeout): port for port in range(start_port, end_port + 1)}
        for future in futures:
            result = future.result()
            if result is not None:
                open_ports.append(result)
    return open_ports

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Port Scanner")
    parser.add_argument("host", help="Host to scan")
    parser.add_argument("start_port", type=int, help="Starting port")
    parser.add_argument("end_port", type=int, help="Ending port")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")
    parser.add_argument("--timeout", type=float, default=1, help="Connection timeout in seconds")
    
    args = parser.parse_args()
    print(f"Scanning {args.host} from port {args.start_port} to {args.end_port} with a timeout of {args.timeout} seconds...")
    open_ports = scan_ports(args.host, args.start_port, args.end_port, args.verbose, args.timeout)
    print(f"Open ports: {open_ports}")
